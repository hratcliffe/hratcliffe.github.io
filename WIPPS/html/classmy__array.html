<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>WIPPS: my_array Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="Doxy.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">WIPPS
   </div>
   <div id="projectbrief">Whistler-mode Interaction Post-Processing Suite</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classmy__array-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">my_array Class Reference<div class="ingroups"><a class="el" href="group__cls.html">Main Classes</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>A basic array class.  
 <a href="classmy__array.html#details">More...</a></p>

<p><code>#include &lt;my_array.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for my_array:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classmy__array.png" usemap="#my_array_map" alt=""/>
  <map id="my_array_map" name="my_array_map">
<area href="classdata__array.html" title="Extended my_array class including axes. " alt="data_array" shape="rect" coords="0,56,96,80"/>
<area href="classdiffusion__coeff.html" title="Diffusion coefficient object. " alt="diffusion_coeff" shape="rect" coords="0,112,96,136"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a02a31adfc96a8d07639c5c6d5da286b5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmy__array.html#a02a31adfc96a8d07639c5c6d5da286b5">my_array</a> ()</td></tr>
<tr class="separator:a02a31adfc96a8d07639c5c6d5da286b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4c6d956a2b07c2b04ccef5b9661a901"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmy__array.html#ac4c6d956a2b07c2b04ccef5b9661a901">my_array</a> (size_t nx, size_t ny=0, size_t nz=0, size_t nt=0)</td></tr>
<tr class="separator:ac4c6d956a2b07c2b04ccef5b9661a901"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad585a78dae4c995322b414c762d70f29"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmy__array.html#ad585a78dae4c995322b414c762d70f29">my_array</a> (size_t <a class="el" href="classmy__array.html#a399b3396f0e8f8613d7daa35b34283da">n_dims</a>, size_t *<a class="el" href="classmy__array.html#a208e179cfbecb51bdac6bb514db766cc">dims</a>)</td></tr>
<tr class="separator:ad585a78dae4c995322b414c762d70f29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad696e8a70adbf90f597638cb6b41b42a"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmy__array.html#ad696e8a70adbf90f597638cb6b41b42a">~my_array</a> ()</td></tr>
<tr class="separator:ad696e8a70adbf90f597638cb6b41b42a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70ead6412331324c2eccbc4fe4398b20"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmy__array.html#a70ead6412331324c2eccbc4fe4398b20">is_good</a> () const </td></tr>
<tr class="separator:a70ead6412331324c2eccbc4fe4398b20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ea925b7cd470bfcf4c1dc67646efe2c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmy__array.html#a6ea925b7cd470bfcf4c1dc67646efe2c">my_array</a> (const <a class="el" href="classmy__array.html">my_array</a> &amp;src)</td></tr>
<tr class="separator:a6ea925b7cd470bfcf4c1dc67646efe2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07a936a1d9f04657f3fb9aa53dcdd416"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmy__array.html#a07a936a1d9f04657f3fb9aa53dcdd416">my_array</a> (<a class="el" href="classmy__array.html">my_array</a> &amp;&amp;src)</td></tr>
<tr class="separator:a07a936a1d9f04657f3fb9aa53dcdd416"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9477d7c47d165c332673b459ee373ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmy__array.html">my_array</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmy__array.html#aa9477d7c47d165c332673b459ee373ad">operator=</a> (const <a class="el" href="classmy__array.html">my_array</a> &amp;src)</td></tr>
<tr class="separator:aa9477d7c47d165c332673b459ee373ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08477d65eefd4677cbfa73c21e347def"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmy__array.html#a08477d65eefd4677cbfa73c21e347def">operator==</a> (const <a class="el" href="classmy__array.html">my_array</a> &amp;rhs) const </td></tr>
<tr class="separator:a08477d65eefd4677cbfa73c21e347def"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e28f8420e86f91196473588207157e1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmy__array.html#a5e28f8420e86f91196473588207157e1">operator!=</a> (const <a class="el" href="classmy__array.html">my_array</a> &amp;rhs) const </td></tr>
<tr class="separator:a5e28f8420e86f91196473588207157e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a4df847409141e630385531cb8e8dd8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__type.html#ga0f3d3a6e2c07b43705a3b4c4060c9d5b">my_type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmy__array.html#a0a4df847409141e630385531cb8e8dd8">disown_data</a> ()</td></tr>
<tr class="separator:a0a4df847409141e630385531cb8e8dd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c23ba96ebbfe32b26442ac9928a966a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmy__array.html#a2c23ba96ebbfe32b26442ac9928a966a">clone_empty</a> (const <a class="el" href="classmy__array.html">my_array</a> &amp;src)</td></tr>
<tr class="separator:a2c23ba96ebbfe32b26442ac9928a966a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0042ab1ccf1a9c68a4aefdb92a50aa8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmy__array.html#aa0042ab1ccf1a9c68a4aefdb92a50aa8">copy_data</a> (<a class="el" href="group__type.html#ga0f3d3a6e2c07b43705a3b4c4060c9d5b">my_type</a> *destination) const </td></tr>
<tr class="separator:aa0042ab1ccf1a9c68a4aefdb92a50aa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a574947259b8320e6cc3384b5b361fe90"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmy__array.html#a574947259b8320e6cc3384b5b361fe90">zero_data</a> ()</td></tr>
<tr class="separator:a574947259b8320e6cc3384b5b361fe90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a399815441ab623aa0b98aa390be56f4f"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmy__array.html#a399815441ab623aa0b98aa390be56f4f">get_dims</a> () const </td></tr>
<tr class="separator:a399815441ab623aa0b98aa390be56f4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a50d6bd2f3f03a8cb4c0e6958e311f9"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmy__array.html#a7a50d6bd2f3f03a8cb4c0e6958e311f9">get_dims</a> (size_t dim) const </td></tr>
<tr class="separator:a7a50d6bd2f3f03a8cb4c0e6958e311f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65cea2b7cdb86a5cd01595c51b88e1c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__type.html#ga0f3d3a6e2c07b43705a3b4c4060c9d5b">my_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmy__array.html#a65cea2b7cdb86a5cd01595c51b88e1c9">get_element</a> (size_t nx) const </td></tr>
<tr class="separator:a65cea2b7cdb86a5cd01595c51b88e1c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a351a0e6fedc34f02ee88faf7eab3b112"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__type.html#ga0f3d3a6e2c07b43705a3b4c4060c9d5b">my_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmy__array.html#a351a0e6fedc34f02ee88faf7eab3b112">get_element</a> (size_t nx, size_t ny) const </td></tr>
<tr class="separator:a351a0e6fedc34f02ee88faf7eab3b112"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1b5417336cb57bec4e3bbd558b7d352"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__type.html#ga0f3d3a6e2c07b43705a3b4c4060c9d5b">my_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmy__array.html#ad1b5417336cb57bec4e3bbd558b7d352">get_element</a> (size_t nx, size_t ny, size_t nz) const </td></tr>
<tr class="separator:ad1b5417336cb57bec4e3bbd558b7d352"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b555415e9ca961ae10868d067e70d1d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__type.html#ga0f3d3a6e2c07b43705a3b4c4060c9d5b">my_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmy__array.html#a1b555415e9ca961ae10868d067e70d1d">get_element</a> (size_t nx, size_t ny, size_t nz, size_t nt) const </td></tr>
<tr class="separator:a1b555415e9ca961ae10868d067e70d1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0cf1e66bb87a2dd504863023f7b083d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__type.html#ga0f3d3a6e2c07b43705a3b4c4060c9d5b">my_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmy__array.html#ab0cf1e66bb87a2dd504863023f7b083d">get_element</a> (size_t <a class="el" href="classmy__array.html#a399b3396f0e8f8613d7daa35b34283da">n_dims</a>, size_t *dim) const </td></tr>
<tr class="separator:ab0cf1e66bb87a2dd504863023f7b083d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4749153167d44907a552b37b6934a92e"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmy__array.html#a4749153167d44907a552b37b6934a92e">get_total_elements</a> () const </td></tr>
<tr class="separator:a4749153167d44907a552b37b6934a92e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12808539e994856f5ef1f58a88197df1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmy__array.html#a12808539e994856f5ef1f58a88197df1">set_element</a> (size_t nx, <a class="el" href="group__type.html#ga0f3d3a6e2c07b43705a3b4c4060c9d5b">my_type</a> val)</td></tr>
<tr class="separator:a12808539e994856f5ef1f58a88197df1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a68bc3abee2e69b4d6f2273d528e47d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmy__array.html#a4a68bc3abee2e69b4d6f2273d528e47d">set_element</a> (size_t nx, size_t ny, <a class="el" href="group__type.html#ga0f3d3a6e2c07b43705a3b4c4060c9d5b">my_type</a> val)</td></tr>
<tr class="separator:a4a68bc3abee2e69b4d6f2273d528e47d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6398b699d31d4ba78e8f86598c72af0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmy__array.html#aa6398b699d31d4ba78e8f86598c72af0">set_element</a> (size_t nx, size_t ny, size_t nz, <a class="el" href="group__type.html#ga0f3d3a6e2c07b43705a3b4c4060c9d5b">my_type</a> val)</td></tr>
<tr class="separator:aa6398b699d31d4ba78e8f86598c72af0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15cc34bca2eba5706efa50f3e5dce4b6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmy__array.html#a15cc34bca2eba5706efa50f3e5dce4b6">set_element</a> (size_t nx, size_t ny, size_t nz, size_t nt, <a class="el" href="group__type.html#ga0f3d3a6e2c07b43705a3b4c4060c9d5b">my_type</a> val)</td></tr>
<tr class="separator:a15cc34bca2eba5706efa50f3e5dce4b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a4a3a4e98876a040cd64421e84728ef"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmy__array.html#a6a4a3a4e98876a040cd64421e84728ef">set_element</a> (size_t <a class="el" href="classmy__array.html#a399b3396f0e8f8613d7daa35b34283da">n_dims</a>, size_t *dim, <a class="el" href="group__type.html#ga0f3d3a6e2c07b43705a3b4c4060c9d5b">my_type</a> val)</td></tr>
<tr class="separator:a6a4a3a4e98876a040cd64421e84728ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc6666203ecd7e742e2e9902d42ee10a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:abc6666203ecd7e742e2e9902d42ee10a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmy__array.html#abc6666203ecd7e742e2e9902d42ee10a">populate_data</a> (T dat_in, size_t n_tot)</td></tr>
<tr class="separator:abc6666203ecd7e742e2e9902d42ee10a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae527e9d9d3dfabcf78ec2c29229b2687"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmy__array.html#ae527e9d9d3dfabcf78ec2c29229b2687">populate_slice</a> (<a class="el" href="group__type.html#ga0f3d3a6e2c07b43705a3b4c4060c9d5b">my_type</a> *dat_in, size_t <a class="el" href="classmy__array.html#a399b3396f0e8f8613d7daa35b34283da">n_dims</a>, size_t *offsets)</td></tr>
<tr class="separator:ae527e9d9d3dfabcf78ec2c29229b2687"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8597ed17c70b4e8a33e7e5784b962afb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmy__array.html#a8597ed17c70b4e8a33e7e5784b962afb">populate_complex_slice</a> (<a class="el" href="group__type.html#ga0f3d3a6e2c07b43705a3b4c4060c9d5b">my_type</a> *dat_in, size_t <a class="el" href="classmy__array.html#a399b3396f0e8f8613d7daa35b34283da">n_dims</a>, size_t *offsets, size_t *sizes)</td></tr>
<tr class="separator:a8597ed17c70b4e8a33e7e5784b962afb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1888d8d0cad4c60f13a236ff6647bed4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmy__array.html#a1888d8d0cad4c60f13a236ff6647bed4">write_to_file</a> (std::fstream &amp;file)</td></tr>
<tr class="separator:a1888d8d0cad4c60f13a236ff6647bed4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bb239c65da0b4d5726045b9cf72add8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmy__array.html#a1bb239c65da0b4d5726045b9cf72add8">read_from_file</a> (std::fstream &amp;file)</td></tr>
<tr class="separator:a1bb239c65da0b4d5726045b9cf72add8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3a78db09019534b2429d7077c282b1d"><td class="memItemLeft" align="right" valign="top">std::vector&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmy__array.html#aa3a78db09019534b2429d7077c282b1d">read_dims_from_file</a> (std::fstream &amp;file)</td></tr>
<tr class="separator:aa3a78db09019534b2429d7077c282b1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e96ee7bd51a171dd4a567b225b98064"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmy__array.html#a6e96ee7bd51a171dd4a567b225b98064">write_section_to_file</a> (std::fstream &amp;file, std::vector&lt; size_t &gt; bounds)</td></tr>
<tr class="separator:a6e96ee7bd51a171dd4a567b225b98064"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84fac626cf975cc3d4c12e7b944b7121"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmy__array.html#a84fac626cf975cc3d4c12e7b944b7121">resize</a> (size_t dim, size_t sz, bool verbose=0)</td></tr>
<tr class="separator:a84fac626cf975cc3d4c12e7b944b7121"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a692abc4d0139d028807a0695c828d3f3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmy__array.html#a692abc4d0139d028807a0695c828d3f3">shift</a> (size_t dim, long n_els)</td></tr>
<tr class="separator:a692abc4d0139d028807a0695c828d3f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae341ebc82ab8a6bfc2eee06d47bee8eb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__type.html#ga0f3d3a6e2c07b43705a3b4c4060c9d5b">my_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmy__array.html#ae341ebc82ab8a6bfc2eee06d47bee8eb">minval</a> (size_t offset=0)</td></tr>
<tr class="separator:ae341ebc82ab8a6bfc2eee06d47bee8eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06baa2d6d3b752616c3a0cd48b8941ab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__type.html#ga0f3d3a6e2c07b43705a3b4c4060c9d5b">my_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmy__array.html#a06baa2d6d3b752616c3a0cd48b8941ab">maxval</a> (size_t offset=0)</td></tr>
<tr class="separator:a06baa2d6d3b752616c3a0cd48b8941ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93be665b1ffcca23f8c0fcc71990e729"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__type.html#ga0f3d3a6e2c07b43705a3b4c4060c9d5b">my_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmy__array.html#a93be665b1ffcca23f8c0fcc71990e729">minval</a> (std::vector&lt; size_t &gt; &amp;ind, size_t offset=0)</td></tr>
<tr class="separator:a93be665b1ffcca23f8c0fcc71990e729"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65b1851aa471a8888d51216ba5dad838"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__type.html#ga0f3d3a6e2c07b43705a3b4c4060c9d5b">my_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmy__array.html#a65b1851aa471a8888d51216ba5dad838">maxval</a> (std::vector&lt; size_t &gt; &amp;ind, size_t offset=0)</td></tr>
<tr class="separator:a65b1851aa471a8888d51216ba5dad838"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a909d0b70d8b4e556d275d97483290e58"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__type.html#ga0f3d3a6e2c07b43705a3b4c4060c9d5b">my_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmy__array.html#a909d0b70d8b4e556d275d97483290e58">partial_maxval</a> (std::vector&lt; std::pair&lt; size_t, size_t &gt; &gt; ranges, std::vector&lt; size_t &gt; &amp;ind)</td></tr>
<tr class="separator:a909d0b70d8b4e556d275d97483290e58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98ac722aae7e0d36b309a19db06f2140"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmy__array.html#a98ac722aae7e0d36b309a19db06f2140">smooth_1d</a> (int n_pts)</td></tr>
<tr class="separator:a98ac722aae7e0d36b309a19db06f2140"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a3635f556b2c4beb8056732ac30410a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmy__array.html#a5a3635f556b2c4beb8056732ac30410a">apply</a> (std::function&lt; <a class="el" href="group__type.html#ga0f3d3a6e2c07b43705a3b4c4060c9d5b">my_type</a>(<a class="el" href="group__type.html#ga0f3d3a6e2c07b43705a3b4c4060c9d5b">my_type</a> arg)&gt; func)</td></tr>
<tr class="separator:a5a3635f556b2c4beb8056732ac30410a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac172be056705e0b5279e228cfa7b3c0c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmy__array.html#ac172be056705e0b5279e228cfa7b3c0c">apply</a> (std::function&lt; <a class="el" href="group__type.html#ga0f3d3a6e2c07b43705a3b4c4060c9d5b">my_type</a>(<a class="el" href="group__type.html#ga0f3d3a6e2c07b43705a3b4c4060c9d5b">my_type</a> arg, <a class="el" href="group__type.html#ga0f3d3a6e2c07b43705a3b4c4060c9d5b">my_type</a> arg2)&gt; func, <a class="el" href="group__type.html#ga0f3d3a6e2c07b43705a3b4c4060c9d5b">my_type</a> arg)</td></tr>
<tr class="separator:ac172be056705e0b5279e228cfa7b3c0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78d5a5e3d75da5714e20936081e1bb25"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmy__array.html#a78d5a5e3d75da5714e20936081e1bb25">apply</a> (std::function&lt; <a class="el" href="group__type.html#ga0f3d3a6e2c07b43705a3b4c4060c9d5b">my_type</a>(<a class="el" href="group__type.html#ga0f3d3a6e2c07b43705a3b4c4060c9d5b">my_type</a> arg)&gt; func, const <a class="el" href="classmy__array.html">my_array</a> &amp;rhs)</td></tr>
<tr class="separator:a78d5a5e3d75da5714e20936081e1bb25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a845f5fa84ec6242fc7021c4b99f17788"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmy__array.html#a845f5fa84ec6242fc7021c4b99f17788">apply</a> (std::function&lt; <a class="el" href="group__type.html#ga0f3d3a6e2c07b43705a3b4c4060c9d5b">my_type</a>(<a class="el" href="group__type.html#ga0f3d3a6e2c07b43705a3b4c4060c9d5b">my_type</a>, <a class="el" href="group__type.html#ga0f3d3a6e2c07b43705a3b4c4060c9d5b">my_type</a>) &gt; func, const <a class="el" href="classmy__array.html">my_array</a> &amp;rhs)</td></tr>
<tr class="separator:a845f5fa84ec6242fc7021c4b99f17788"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a7475e42e523ef980666314f9795675c3"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmy__array.html#a7475e42e523ef980666314f9795675c3">construct</a> ()</td></tr>
<tr class="separator:a7475e42e523ef980666314f9795675c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0ec9e401c5ad4243b9d5574763488ac"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmy__array.html#ab0ec9e401c5ad4243b9d5574763488ac">alloc_all</a> (const size_t <a class="el" href="classmy__array.html#a399b3396f0e8f8613d7daa35b34283da">n_dims</a>, const size_t *const <a class="el" href="classmy__array.html#a208e179cfbecb51bdac6bb514db766cc">dims</a>)</td></tr>
<tr class="separator:ab0ec9e401c5ad4243b9d5574763488ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4694c00cf2f06340dd85780dfa98f150"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmy__array.html#a4694c00cf2f06340dd85780dfa98f150">get_indices_from_offset</a> (size_t offset) const </td></tr>
<tr class="separator:a4694c00cf2f06340dd85780dfa98f150"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e65fdd6cf2187da80785c4da8f93da3"><td class="memItemLeft" align="right" valign="top">virtual long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmy__array.html#a1e65fdd6cf2187da80785c4da8f93da3">get_index</a> (size_t <a class="el" href="classmy__array.html#a399b3396f0e8f8613d7daa35b34283da">n_dims</a>, size_t *dim) const </td></tr>
<tr class="separator:a1e65fdd6cf2187da80785c4da8f93da3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbe0aa41a25c99abecea8fbf7eeb2860"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmy__array.html#afbe0aa41a25c99abecea8fbf7eeb2860">get_index</a> (size_t nx) const </td></tr>
<tr class="separator:afbe0aa41a25c99abecea8fbf7eeb2860"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed38f928044ea3861682960413feb116"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmy__array.html#aed38f928044ea3861682960413feb116">get_index</a> (size_t nx, size_t ny) const </td></tr>
<tr class="separator:aed38f928044ea3861682960413feb116"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a1dea55fdf6d8d3e465408bb1bc42ef"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmy__array.html#a8a1dea55fdf6d8d3e465408bb1bc42ef">get_index</a> (size_t nx, size_t ny, size_t nz) const </td></tr>
<tr class="separator:a8a1dea55fdf6d8d3e465408bb1bc42ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d4cbbf1acb23850c2b0485fb6d3819b"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmy__array.html#a9d4cbbf1acb23850c2b0485fb6d3819b">get_index</a> (size_t nx, size_t ny, size_t nz, size_t nt) const </td></tr>
<tr class="separator:a9d4cbbf1acb23850c2b0485fb6d3819b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43ccd00a6590c83b0fe5b75ce37fbd62"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__type.html#ga0f3d3a6e2c07b43705a3b4c4060c9d5b">my_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmy__array.html#a43ccd00a6590c83b0fe5b75ce37fbd62">get_element_from_index</a> (size_t ind) const </td></tr>
<tr class="separator:a43ccd00a6590c83b0fe5b75ce37fbd62"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a399b3396f0e8f8613d7daa35b34283da"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmy__array.html#a399b3396f0e8f8613d7daa35b34283da">n_dims</a></td></tr>
<tr class="separator:a399b3396f0e8f8613d7daa35b34283da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a208e179cfbecb51bdac6bb514db766cc"><td class="memItemLeft" align="right" valign="top">size_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmy__array.html#a208e179cfbecb51bdac6bb514db766cc">dims</a></td></tr>
<tr class="separator:a208e179cfbecb51bdac6bb514db766cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40ed5070857b2995d1987aa9e2e919ae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__type.html#ga0f3d3a6e2c07b43705a3b4c4060c9d5b">my_type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmy__array.html#a40ed5070857b2995d1987aa9e2e919ae">data</a></td></tr>
<tr class="separator:a40ed5070857b2995d1987aa9e2e919ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a464877bc874ede3736f82060873756d3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmy__array.html#a464877bc874ede3736f82060873756d3">populate_mirror_fastest</a> (<a class="el" href="classdata__array.html">data_array</a> &amp;data_out, <a class="el" href="group__type.html#ga0f3d3a6e2c07b43705a3b4c4060c9d5b">my_type</a> *result_in, size_t total_els)</td></tr>
<tr class="separator:a464877bc874ede3736f82060873756d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A basic array class. </p>
<p>Contains dimension information and data. Can be rectangular of any n_dims or ragged of 2 (rows of different lengths). Get_index and get_total_elements account for all details of internal layout in memory. For 1-4 dims individual getter/setter functions are given. For larger arrays one must construc the array of indexes. NOTE the backing memory is old style with Fortran style internal ordering (for ease of SDF interfacing). But contigous memory and pointer arithmetic give major speed advantage and we very rarely change size on the fly. However nothing outside this class should need to do anything except access by index and populate by element, slice or entire. Internal ordering is Fortran style (for ease of SDF interfacing). </p><dl class="section author"><dt>Author</dt><dd>Heather Ratcliffe </dd></dl>
<dl class="section date"><dt>Date</dt><dd>21/09/2015 </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a02a31adfc96a8d07639c5c6d5da286b5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">my_array::my_array </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Default constructor </p>

</div>
</div>
<a class="anchor" id="ac4c6d956a2b07c2b04ccef5b9661a901"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">my_array::my_array </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>ny</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nz</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nt</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>1 to 4 d rectangular array creator</p>
<p>Sets up a n-d rectangular array for n = 1 to 4. Helper avoids user having to construct size_t array of dims. Default values mean any dimensions not supplied will be 0 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nx</td><td>Size of x dimension </td></tr>
    <tr><td class="paramname">ny</td><td>Size of y dimension, default 0 </td></tr>
    <tr><td class="paramname">nz</td><td>Size of z dimension, default 0 </td></tr>
    <tr><td class="paramname">nt</td><td>Size of t dimension, default 0</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad585a78dae4c995322b414c762d70f29"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">my_array::my_array </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n_dims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>dims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Arbitrary dim rectangular array</p>
<p>Sets up internals of array including memory allocation </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n_dims</td><td>Rank of array to create </td></tr>
    <tr><td class="paramname">dims</td><td>Array of dimensions of array to create</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad696e8a70adbf90f597638cb6b41b42a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">my_array::~my_array </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Destructor</p>
<p>Clean up explicit allocations</p>

</div>
</div>
<a class="anchor" id="a6ea925b7cd470bfcf4c1dc67646efe2c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">my_array::my_array </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmy__array.html">my_array</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy constructor</p>
<p>Copy src to a new instance, making a duplicate of data </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Array to copy from</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a07a936a1d9f04657f3fb9aa53dcdd416"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">my_array::my_array </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmy__array.html">my_array</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Move constructor</p>
<p>Move src to a new instance i.e. copy fields but don't move memory. Src becomes empty afterwards </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Array to move</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ab0ec9e401c5ad4243b9d5574763488ac"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void my_array::alloc_all </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>n_dims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t *const&#160;</td>
          <td class="paramname"><em>dims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Takes care of memory allocation</p>
<p>Allocate dims array and data. If any size is zero, any exceeds MAX_SIZE, or overall exceeds MAX_SIZE_TOT, print error and stop. NB inputs will not be modified, will be copied </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n_dims</td><td>Rank of array to allocate </td></tr>
    <tr><td class="paramname">dims</td><td>Dimensions of array to allocate</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5a3635f556b2c4beb8056732ac30410a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void my_array::apply </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; <a class="el" href="group__type.html#ga0f3d3a6e2c07b43705a3b4c4060c9d5b">my_type</a>(<a class="el" href="group__type.html#ga0f3d3a6e2c07b43705a3b4c4060c9d5b">my_type</a> arg)&gt;&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Apply a function to each element of array. func must take and return a my_type or type convertible to this </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Function to apply </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac172be056705e0b5279e228cfa7b3c0c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void my_array::apply </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; <a class="el" href="group__type.html#ga0f3d3a6e2c07b43705a3b4c4060c9d5b">my_type</a>(<a class="el" href="group__type.html#ga0f3d3a6e2c07b43705a3b4c4060c9d5b">my_type</a> arg, <a class="el" href="group__type.html#ga0f3d3a6e2c07b43705a3b4c4060c9d5b">my_type</a> arg2)&gt;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__type.html#ga0f3d3a6e2c07b43705a3b4c4060c9d5b">my_type</a>&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Apply a function to each element of array. func must take two my_type and return one my_type or type convertible to this </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Function to apply </td></tr>
    <tr><td class="paramname">arg</td><td>Second argument to function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a78d5a5e3d75da5714e20936081e1bb25"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void my_array::apply </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; <a class="el" href="group__type.html#ga0f3d3a6e2c07b43705a3b4c4060c9d5b">my_type</a>(<a class="el" href="group__type.html#ga0f3d3a6e2c07b43705a3b4c4060c9d5b">my_type</a> arg)&gt;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmy__array.html">my_array</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Fill one array from another mapping elements using function. func must take and return a my_type or type convertible to this. Each element of the rhs is tranformed with func and placed into this array </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Transform function to apply to elements </td></tr>
    <tr><td class="paramname">rhs</td><td>Array to transform </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a845f5fa84ec6242fc7021c4b99f17788"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void my_array::apply </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; <a class="el" href="group__type.html#ga0f3d3a6e2c07b43705a3b4c4060c9d5b">my_type</a>(<a class="el" href="group__type.html#ga0f3d3a6e2c07b43705a3b4c4060c9d5b">my_type</a>, <a class="el" href="group__type.html#ga0f3d3a6e2c07b43705a3b4c4060c9d5b">my_type</a>) &gt;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmy__array.html">my_array</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Transform one array using another. func must take a pair of my_type and return a my_type or types convertible to this. Func is called with each element of this array and each element of rhs and the result placed back into this. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Function to apply </td></tr>
    <tr><td class="paramname">rhs</td><td>Second parameters to func </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2c23ba96ebbfe32b26442ac9928a966a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void my_array::clone_empty </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmy__array.html">my_array</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialise this to same sizes as src</p>
<p>This will be a valid empty array of size matching src. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Array to copy dims from</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7475e42e523ef980666314f9795675c3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void my_array::construct </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Shared contructor code</p>
<p>Sets default values</p>

<p>Reimplemented in <a class="el" href="classdata__array.html#a8e325412ed2e2e644fcdebbf73f76a58">data_array</a>.</p>

</div>
</div>
<a class="anchor" id="aa0042ab1ccf1a9c68a4aefdb92a50aa8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool my_array::copy_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__type.html#ga0f3d3a6e2c07b43705a3b4c4060c9d5b">my_type</a> *&#160;</td>
          <td class="paramname"><em>destination</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy the data into destination array</p>
<p>Data is not lost, but a direct copy is made. Destination size will NOT be checked, the entirety of data is copied. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">destination</td><td>Pointer to destination to copy to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0, error checking not yet implemented</dd></dl>

</div>
</div>
<a class="anchor" id="a0a4df847409141e630385531cb8e8dd8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__type.html#ga0f3d3a6e2c07b43705a3b4c4060c9d5b">my_type</a> * my_array::disown_data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Disown and return data pointer</p>
<p>Surrenders ownership of memory pointed to by data, nullifies dimensions and returns pointer. NB if this pointer is not kept and manually freed, memory will leak. This array will then be an empty array </p><dl class="section return"><dt>Returns</dt><dd>Pointer to the disowned data array</dd></dl>

</div>
</div>
<a class="anchor" id="a399815441ab623aa0b98aa390be56f4f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t my_array::get_dims </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return rank of array</p>

</div>
</div>
<a class="anchor" id="a7a50d6bd2f3f03a8cb4c0e6958e311f9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t my_array::get_dims </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dim</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return size of dimension dim</p>

</div>
</div>
<a class="anchor" id="a65cea2b7cdb86a5cd01595c51b88e1c9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__type.html#ga0f3d3a6e2c07b43705a3b4c4060c9d5b">my_type</a> my_array::get_element </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get element</p>
<p>Return element at nx. Out of range etc will return 0.0 </p>

</div>
</div>
<a class="anchor" id="a351a0e6fedc34f02ee88faf7eab3b112"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__type.html#ga0f3d3a6e2c07b43705a3b4c4060c9d5b">my_type</a> my_array::get_element </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>ny</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>As <a class="el" href="classmy__array.html#a65cea2b7cdb86a5cd01595c51b88e1c9">my_array::get_element(size_t nx) const </a>but for 2-D arrays </p>

</div>
</div>
<a class="anchor" id="ad1b5417336cb57bec4e3bbd558b7d352"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__type.html#ga0f3d3a6e2c07b43705a3b4c4060c9d5b">my_type</a> my_array::get_element </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>ny</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>As <a class="el" href="classmy__array.html#a65cea2b7cdb86a5cd01595c51b88e1c9">my_array::get_element(size_t nx) const </a>but for 3-D arrays </p>

</div>
</div>
<a class="anchor" id="a1b555415e9ca961ae10868d067e70d1d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__type.html#ga0f3d3a6e2c07b43705a3b4c4060c9d5b">my_type</a> my_array::get_element </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>ny</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>As <a class="el" href="classmy__array.html#a65cea2b7cdb86a5cd01595c51b88e1c9">my_array::get_element(size_t nx) const </a>but for 4-D arrays </p>

</div>
</div>
<a class="anchor" id="ab0cf1e66bb87a2dd504863023f7b083d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__type.html#ga0f3d3a6e2c07b43705a3b4c4060c9d5b">my_type</a> my_array::get_element </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n_dims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>dim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>As <a class="el" href="classmy__array.html#a65cea2b7cdb86a5cd01595c51b88e1c9">my_array::get_element(size_t nx) const </a>but for arbitrary dimension arrays. Supply n_dims and an array of the required indices </p>

</div>
</div>
<a class="anchor" id="a43ccd00a6590c83b0fe5b75ce37fbd62"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__type.html#ga0f3d3a6e2c07b43705a3b4c4060c9d5b">my_type</a> my_array::get_element_from_index </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>ind</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get element by 1-d offset</p>
<p>Returns the element at index in the 1-D backing array. Ind should be found using one of the get_index options</p>

</div>
</div>
<a class="anchor" id="a1e65fdd6cf2187da80785c4da8f93da3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long my_array::get_index </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n_dims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>dim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert n-d index into 1-d index</p>
<p>This requires passing integer array and loop so is slower than the dedicated functions (get_index(nx, ...)) that follow</p>

</div>
</div>
<a class="anchor" id="afbe0aa41a25c99abecea8fbf7eeb2860"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long my_array::get_index </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get index of element at nx</p>
<p>Takes care of all bounds checking and disposition in memory. Returns -1 if out of range of any sort, otherwise, the index into backing data array. This function is called often so we make it as simple as possible and write one for each number of args.</p>

</div>
</div>
<a class="anchor" id="aed38f928044ea3861682960413feb116"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long my_array::get_index </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>ny</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>See <a class="el" href="classmy__array.html#afbe0aa41a25c99abecea8fbf7eeb2860">my_array::get_index(size_t nx) const</a></p>

</div>
</div>
<a class="anchor" id="a8a1dea55fdf6d8d3e465408bb1bc42ef"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long my_array::get_index </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>ny</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>See <a class="el" href="classmy__array.html#afbe0aa41a25c99abecea8fbf7eeb2860">my_array::get_index(size_t nx) const</a></p>

</div>
</div>
<a class="anchor" id="a9d4cbbf1acb23850c2b0485fb6d3819b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long my_array::get_index </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>ny</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>See <a class="el" href="classmy__array.html#afbe0aa41a25c99abecea8fbf7eeb2860">my_array::get_index(size_t nx) const</a></p>

</div>
</div>
<a class="anchor" id="a4694c00cf2f06340dd85780dfa98f150"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; size_t &gt; my_array::get_indices_from_offset </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>offset</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get vector of indices from 1-d index</p>
<p>Takes a 1-d index and returns the n-d index vector. If offset is out of range, empty vector is returned.</p>

</div>
</div>
<a class="anchor" id="a4749153167d44907a552b37b6934a92e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t my_array::get_total_elements </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return total size of array </p><dl class="section return"><dt>Returns</dt><dd>The total number of data elements in array </dd></dl>

</div>
</div>
<a class="anchor" id="a70ead6412331324c2eccbc4fe4398b20"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool my_array::is_good </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Check memory allocation etc worked </p><dl class="section return"><dt>Returns</dt><dd>True if good, false else </dd></dl>

<p>Reimplemented in <a class="el" href="classdata__array.html#addf2c1b94dff445a2e7ca4a3cc258ea0">data_array</a>.</p>

</div>
</div>
<a class="anchor" id="a06baa2d6d3b752616c3a0cd48b8941ab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__type.html#ga0f3d3a6e2c07b43705a3b4c4060c9d5b">my_type</a> my_array::maxval </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find maximum value of data</p>
<p>Finds the maximum of the array after offset, using linear search through contiguous memory. Offset should be obtained using one of the get_index functions. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>1-D array offset to start search from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The maximum value of data</dd></dl>

</div>
</div>
<a class="anchor" id="a65b1851aa471a8888d51216ba5dad838"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__type.html#ga0f3d3a6e2c07b43705a3b4c4060c9d5b">my_type</a> my_array::maxval </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>ind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find maximum value of data</p>
<p>Finds the maximum of the array after offset, using linear search through contiguous memory. Offset should be obtained using one of the get_index functions. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">offset</td><td>1-D array offset to start search from </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ind</td><td>The indices where max value is located </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The maximum value of data</dd></dl>

</div>
</div>
<a class="anchor" id="ae341ebc82ab8a6bfc2eee06d47bee8eb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__type.html#ga0f3d3a6e2c07b43705a3b4c4060c9d5b">my_type</a> my_array::minval </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find minimum value of data</p>
<p>Finds the minimum of the array after offset, using linear search through contiguous memory. Offset should be obtained using one of the get_index functions. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>1-D array offset to start search from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The minimum value of data</dd></dl>

</div>
</div>
<a class="anchor" id="a93be665b1ffcca23f8c0fcc71990e729"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__type.html#ga0f3d3a6e2c07b43705a3b4c4060c9d5b">my_type</a> my_array::minval </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>ind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find minimum value of data</p>
<p>Finds the minimum of the array after offset, using linear search through contiguous memory. Offset should be obtained using one of the get_index functions. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">offset</td><td>1-D array offset to start search from </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ind</td><td>The indices where min value is located </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The minimum value of data</dd></dl>

</div>
</div>
<a class="anchor" id="a5e28f8420e86f91196473588207157e1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool my_array::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmy__array.html">my_array</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>See <a class="el" href="classmy__array.html#a08477d65eefd4677cbfa73c21e347def">my_array::operator==()</a> </p>

</div>
</div>
<a class="anchor" id="aa9477d7c47d165c332673b459ee373ad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmy__array.html">my_array</a> &amp; my_array::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmy__array.html">my_array</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy assignment</p>
<p>Sets this equal to a (deep) copy of source </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Array to copy from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Copy of input</dd></dl>

</div>
</div>
<a class="anchor" id="a08477d65eefd4677cbfa73c21e347def"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool my_array::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmy__array.html">my_array</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Equality operator</p>
<p>Check this is equal to rhs. Since copies are always deep, we check values, not data pointers </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>Array to compare to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Boolean true if equal, false else</dd></dl>

</div>
</div>
<a class="anchor" id="a909d0b70d8b4e556d275d97483290e58"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__type.html#ga0f3d3a6e2c07b43705a3b4c4060c9d5b">my_type</a> my_array::partial_maxval </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::pair&lt; size_t, size_t &gt; &gt;&#160;</td>
          <td class="paramname"><em>ranges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>ind</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Maximum value over part of range</p>
<p>WARNING: this is slow. Perhaps very slow. I'm using routines I have to knock it up quickly. Beware!!! </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">ranges</td><td>The indices to consider between on each dimension </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ind</td><td>The indices where max was located </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The maximum value over given ranges</dd></dl>

</div>
</div>
<a class="anchor" id="a8597ed17c70b4e8a33e7e5784b962afb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool my_array::populate_complex_slice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__type.html#ga0f3d3a6e2c07b43705a3b4c4060c9d5b">my_type</a> *&#160;</td>
          <td class="paramname"><em>dat_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n_dims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>sizes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Populate a slice of array from the input array.</p>
<p>Extends populate_slice to fill an array slice from a larger array. As populate slice, assumes destination is a section of dimension m, with some finite offset in dimensions from m to n only. Assuming dat_in is a 1-d array in Fortran order (see get_element) this will read the proper subsection. Note this works fine for simple slices but costs more </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dat_in</td><td>pointer to data </td></tr>
    <tr><td class="paramname">n_dims</td><td>Dimensionality of input (must be less than dimension of array) </td></tr>
    <tr><td class="paramname">offsets</td><td>Offsets in the other dimensions </td></tr>
    <tr><td class="paramname">sizes</td><td>Sizes of input array </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 (success), 1 else </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000013">Todo:</a></b></dt><dd>Add testing of this </dd></dl>

</div>
</div>
<a class="anchor" id="abc6666203ecd7e742e2e9902d42ee10a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">template bool my_array::populate_data </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>dat_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n_tot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Fill array</p>
<p>Populates this array from dat_in. n_tot should be the total number of elements in dat_in. The smaller of n_tot and the total number of elements in this array are copied. dat_in must match this array in row-column ordering and rank. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dat_in</td><td>Source of copy </td></tr>
    <tr><td class="paramname">n_tot</td><td>Total number of elements to copy </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 (sucess) 1 (error).</dd></dl>

</div>
</div>
<a class="anchor" id="ae527e9d9d3dfabcf78ec2c29229b2687"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool my_array::populate_slice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__type.html#ga0f3d3a6e2c07b43705a3b4c4060c9d5b">my_type</a> *&#160;</td>
          <td class="paramname"><em>dat_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n_dims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>offsets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Populate a slice of array from the input array.</p>
<p>Fill an array slice, that is a section of rank m &lt; n_dims, with some finite offset in dimensions from m to n_dims only. offsets_n_dims = n_dims - m is the size of the array of offsets provided. E.g. to fill a row of a 3-d array call with n_dims_in = 3-1=2 and offsets={column, plane}. Or to fill an array of shape (x, y, t) at a single time value t_0, use n_dims_in=1, offsets={t_0}. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dat_in</td><td>pointer to data </td></tr>
    <tr><td class="paramname">n_dims</td><td>Dimensionality of input (must be less than dimension of array) </td></tr>
    <tr><td class="paramname">offsets</td><td>Offsets in the other dimensions </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 for success, 1 for error</dd></dl>

</div>
</div>
<a class="anchor" id="aa3a78db09019534b2429d7077c282b1d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; size_t &gt; my_array::read_dims_from_file </td>
          <td>(</td>
          <td class="paramtype">std::fstream &amp;&#160;</td>
          <td class="paramname"><em>file</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read dimensions from array file</p>
<p>Reads dims from file into vector. Returns empty vector on read error The layout is: sizeof(size_t) sizeof(my_type) io_verification_code Version string Next_block n_dims dims[n_dims] Next_block data IMPORTANT: the VERSION specifier links output files to code. If the file output is changed, commit and clean build with a bumped major version number tag to correctly specify this </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>Filestream to read from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of dimensions</dd></dl>

</div>
</div>
<a class="anchor" id="a1bb239c65da0b4d5726045b9cf72add8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool my_array::read_from_file </td>
          <td>(</td>
          <td class="paramtype">std::fstream &amp;&#160;</td>
          <td class="paramname"><em>file</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read array from file</p>
<p>Reads data from file. This array should have already been created in the correct shape, otherwise we return an error.</p>
<p>The layout is: sizeof(size_t) sizeof(my_type) io_verification_code Version string Next_block n_dims dims[n_dims] Next_block data IMPORTANT: the VERSION specifier links output files to code. If the file output is changed, commit and clean build with a bumped major version number tag to correctly specify this </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>Filestream to read from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 (success), 1 else</dd></dl>

</div>
</div>
<a class="anchor" id="a84fac626cf975cc3d4c12e7b944b7121"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool my_array::resize </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>verbose</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Resize <a class="el" href="classmy__array.html" title="A basic array class. ">my_array</a> on the fly</p>
<p>dim is the dimension to resize, sz the new size. If sz &lt; dims[dim] the first sz rows will be kept and the rest deleted. If sz &gt; dims[dim] the new elements will be added zero initialised. Note due to using 1-d memory layout both cases require copying all data and therefore briefly memory to store the old and new arrays. However shinking the last dimension does not necessarily require a copy. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dim</td><td>Dimension to resize </td></tr>
    <tr><td class="paramname">sz</td><td>New size for dimension </td></tr>
    <tr><td class="paramname">verbose</td><td>Flag to print extra info </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 (nothing to report) 1 else, including "new size matches, nothing done"</dd></dl>

</div>
</div>
<a class="anchor" id="a12808539e994856f5ef1f58a88197df1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool my_array::set_element </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__type.html#ga0f3d3a6e2c07b43705a3b4c4060c9d5b">my_type</a>&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets array element</p>
<p>Sets elements at nx. </p><dl class="section return"><dt>Returns</dt><dd>1 if nx is out of range or array is not rank 1, 0 else.</dd></dl>

</div>
</div>
<a class="anchor" id="a4a68bc3abee2e69b4d6f2273d528e47d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool my_array::set_element </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>ny</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__type.html#ga0f3d3a6e2c07b43705a3b4c4060c9d5b">my_type</a>&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>As <a class="el" href="classmy__array.html#a12808539e994856f5ef1f58a88197df1">my_array::set_element(size_t nx, my_type val)</a> for 2-D arrays </p>

</div>
</div>
<a class="anchor" id="aa6398b699d31d4ba78e8f86598c72af0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool my_array::set_element </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>ny</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__type.html#ga0f3d3a6e2c07b43705a3b4c4060c9d5b">my_type</a>&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>As <a class="el" href="classmy__array.html#a12808539e994856f5ef1f58a88197df1">my_array::set_element(size_t nx, my_type val)</a> for 3-D arrays </p>

</div>
</div>
<a class="anchor" id="a15cc34bca2eba5706efa50f3e5dce4b6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool my_array::set_element </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>ny</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__type.html#ga0f3d3a6e2c07b43705a3b4c4060c9d5b">my_type</a>&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>As <a class="el" href="classmy__array.html#a12808539e994856f5ef1f58a88197df1">my_array::set_element(size_t nx, my_type val)</a> for 4-D arrays </p>

</div>
</div>
<a class="anchor" id="a6a4a3a4e98876a040cd64421e84728ef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool my_array::set_element </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n_dims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__type.html#ga0f3d3a6e2c07b43705a3b4c4060c9d5b">my_type</a>&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>As <a class="el" href="classmy__array.html#a12808539e994856f5ef1f58a88197df1">my_array::set_element(size_t nx, my_type val)</a> for N-D arrays, using array of indexes </p>

</div>
</div>
<a class="anchor" id="a692abc4d0139d028807a0695c828d3f3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool my_array::shift </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>n_els</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Shift array on dimension dim by n_els</p>
<p>Because of individual getter/setter per dimensionality, we use the 1-d backing to do this. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dim</td><td>Dimension to shift, (0 to n_dims-1) </td></tr>
    <tr><td class="paramname">n_els</td><td>Number of elements to shift by. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 (success) 1 else </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000014">Todo:</a></b></dt><dd>Fix special case </dd></dl>

</div>
</div>
<a class="anchor" id="a98ac722aae7e0d36b309a19db06f2140"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void my_array::smooth_1d </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n_pts</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Smooth a 1-d <a class="el" href="classdata__array.html" title="Extended my_array class including axes. ">data_array</a></p>
<p>Smooths the data backing array. This does strange things for non-1d data at the ends. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n_pts</td><td>Smoothing width</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6e96ee7bd51a171dd4a567b225b98064"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool my_array::write_section_to_file </td>
          <td>(</td>
          <td class="paramtype">std::fstream &amp;&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; size_t &gt;&#160;</td>
          <td class="paramname"><em>bounds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write a subsection of array to file</p>
<p>We write only the section delimited by bounds, which should have two elements for each dimension of this array. The layout is: sizeof(size_t) sizeof(my_type) io_verification_code Version string Next_block n_dims dims[n_dims] Next_block data IMPORTANT: the VERSION specifier links output files to code. If the file output is changed, commit and clean build with a bumped major version number tag to correctly specify this </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>Filestream to write to </td></tr>
    <tr><td class="paramname">bounds</td><td>Vector of indices delimiting subsection to write </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 (success) 1 (error)</dd></dl>

</div>
</div>
<a class="anchor" id="a1888d8d0cad4c60f13a236ff6647bed4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool my_array::write_to_file </td>
          <td>(</td>
          <td class="paramtype">std::fstream &amp;&#160;</td>
          <td class="paramname"><em>file</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write array to file</p>
<p>Writes array to file. Data is in a few blocks each starting with a number defining their end position in the file. The layout is: sizeof(size_t) sizeof(my_type) io_verification_code Version string Next_block n_dims dims[n_dims] Next_block data IMPORTANT: the VERSION specifier links output files to code. If the file output is changed, commit and clean build with a bumped major version number tag to correctly specify this </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>Filestream to write to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 (success) 1 (error)</dd></dl>

</div>
</div>
<a class="anchor" id="a574947259b8320e6cc3384b5b361fe90"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void my_array::zero_data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reset data to 0</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a class="anchor" id="a464877bc874ede3736f82060873756d3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool populate_mirror_fastest </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdata__array.html">data_array</a> &amp;&#160;</td>
          <td class="paramname"><em>data_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__type.html#ga0f3d3a6e2c07b43705a3b4c4060c9d5b">my_type</a> *&#160;</td>
          <td class="paramname"><em>result_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>total_els</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copy FFTW data into array</p>
<p>For real data an FFT has a redundant half so FFTW returns array od size (dims[0]/2 +1)*dims[...]*dims[n-1] (Note that our first dim is FFTWs last). Since we want all k we have to mirror this to obey H(-f, -g) = H(f, g). For simplicity we enforce this on k_x, omega pair only. Data is assumed unshifted. Should work for 1-3 dimensions. 1st dimension will be returned shifted to 0-in-centre</p><dl class="todo"><dt><b><a class="el" href="todo.html#_todo000008">Todo:</a></b></dt><dd>Which side is negative k?</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000009">Todo:</a></b></dt><dd>Can we replace reverse_copy with slice fillers and remove friendship? </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a40ed5070857b2995d1987aa9e2e919ae"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__type.html#ga0f3d3a6e2c07b43705a3b4c4060c9d5b">my_type</a>* my_array::data</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The data </p>

</div>
</div>
<a class="anchor" id="a208e179cfbecb51bdac6bb514db766cc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t* my_array::dims</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Array dimensions </p>

</div>
</div>
<a class="anchor" id="a399b3396f0e8f8613d7daa35b34283da"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t my_array::n_dims</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Number of dimensions </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Jun 6 2017 14:40:07 for WIPPS by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.9.1
</small></address>
</body>
</html>
